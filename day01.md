# 1.1 디자인 패턴
  
  ## 1.1.1 싱글톤 패턴
    싱글톤 패턴이린 하나의 클래스에 하나의 인스턴스를 가지는 패턴. 주로 DB인스턴스에 많이 쓰인다.
    장점 : 인스턴스 생성 비용이 줄어든다.
    단점 : 의존성이 높아짐. 이로 인해 TDD에 걸림돌이 된다. 단위테스트를 할 때 각 테스트는 서로 독립적이어야 하는데 싱글톤 패턴이 독립적인 테스트를 어렵게 만든다.
          모듈간의 결합을 강하게 만든다. 이는 의존성 주입을 통해 해결할 수 있다.
    
    자바스크립트는 리터럴이나 new Object로 객체를 생성하게 되면 자체적으로 싱글톤 패턴이 구현됨.
    자바는 static을 통해 간단하게 싱글톤을 구현할 수 있다. static이 붙게되면 static으로 할당된 메모리는 공유되어 사용됨.
    
    
    의존성 주입(Dependency Injection, DI)
      메인 모듈이 하위 모듈에 의존성을 주기보다 중간에 의존성 주입자가 이 부분을 가로채 메인모듈이 '간접적'으로 의존성을 주입하게 하는 방식.
      장점: 모듈들의 결합이 느슨해져 있기떄문에 모듈 교체가 쉽고 테스팅을 수월하게 할 수 있음. 또한 구현할 때 추상화 레이어를 기반으로 구현체를 넣어 주기 떄문에 애플리케이션 의존성 방향이 일관됨.
           애플리케이션을 쉽게 추론할 수 있으며 모듈간 관계가 좀 더 명확해짐.
      단점: 모듈들이 더욱더 분리되므로 클래스 수가 늘어나 복잡성이 증가됨. 런타임 패널티가 생기기도 함.
      
      의존성 주입의 원칙 : 상위 모듈은 하위 모듈에서 어떠한 것도 가져오지 않아야 함. 또한 둘 다 추상화에 의존해야 하며, 추상화는 세부사항에 의존하지 않아야함.
  
  ## 1.1.2 팩토리 패턴
    객체를 사용하는 코드에서 객체 생성 부분을 뗴어내 추상화한 패턴. 상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고, 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴.
    상, 하위 클래스가 분리 되므로 느슨한 결합을 가지며 많은 유연성을 가지게 된다. 그리고 객체 생성 로직이 따로 뗴어져 있으므로 코드를 리팩터링해도 한 곳만 고치면 되니 유지보수성도 증가함.
    
  ## 1.1.3 전략 패턴
    객체의 행위를 바꾸고 싶을 때 '직접' 수정하는 것이 아니라 '캡슐화한 알고리즘'을 컨텍스트 안에서 바꿔주면서 상호 교체를 가능하게 하는 패턴. 대표적으로 node.js의 패스포트 라이브러리가 있다.
    EX) 쇼핑몰에서 결제할 떄 네이버페이, 카카오페이 등 결제방식을 선택하는 예
   
  ## 1.1.4 옵저버 패턴
    옵저버 패턴은 주체(관찰자)가 어떤 객체의 상태 변화를 관찰하다가 상태 변화가 있을 때 마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴.
    EX) 트위터의 팔로우 트윗 알림 서비스
    
    이벤트 기반 시스템에 주로 사용되며 MVC 패턴에도 사용된다. 
    
  ## 1.1.5 프록시 패턴과 프록시 서버
    프록시 패턴은 대상 객체에 접근하기 전 그 접근에 대한 흐름을 가로채 대상 객체 앞단의 인터페이스 역할을 하는 디자인 패턴입니다.
    이를 통해 객체의 속성, 변환 등을 보완하며 보안, 데이터 검증, 캐싱, 로깅에 사용함. 이는 앞서 설명한 프록시 객체로 쓰이기도 하지만 프록시 서버로도 활용된다.
    
    프록시 서버(Proxy Server)란?
    서버와 클라이언트 사이에 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용프로그램을 말함.
    프록시 서버에서의 캐싱 : 캐시안에 정보를 담아두고 정보를 요청 받았을 때 멀리 떨어진 원격 서버에 요청하지 않고 캐시 속 데이터를 활용하는 것. 불필요한 트래픽을 줄일 수 있다.
    
  ## 1.1.6 이더레이터 패턴
    이터레이터를 사용하여 컬렉션의 요소들에 접근하는 디자인 패턴.

    이터레이터 프로토콜 : 이터러블한 객체들을 순회할 때 쓰이는 규칙
    이터러블한 객체 : 반복 가능한 객체로 배열을 일반화한 객체
    
  ## 1.1.7 노출모듈 패턴
  노출모듈 패턴은 즉시 실행 함수를 통해 private, public 같은 접근 제어자를 만드는 패턴을 말함. JS는 접근 제어자가 존재하지 않고 전역 범위에서 스크립트가 실행됨. 따라서 노출모듈 패턴을 통해 접근   제어자를 구현하기도 함.
  
  public : 클래스에 정의된 함수에서 접근 가능하며 자식 클래스와 외부 클래스에서 접근 가능한 범위
  protected : 클래스에 정의 된 함수와 자식클래스에서 접근 가능함. but 외부 클래스에선 접근 불가
  private : 클래스에 정의 된 함수만 접근 가능. 자식, 외부 클래스 접근 불가
  즉시 실행 함수 : 함수를 정의하자마자 바로 호출하는 함수. 초기화 코드, 라이브러리 내 전역 변수의 충돌 방지 등에 사용한다.
    
  ## 1.1.8 MVC 패턴
  모델, 뷰, 컨트롤러로 이루어진 디자인 패턴임.
  애플리케이션의 구성 요소를 세 가지 역할로 구분하여 개발 프로세스에서 각각의 구성 요소에만 집중해 개발할 수 있음. 재사용성과 확장성이 좋으나 애플리케이션이 복잡해질수록 모델과 뷰의 관계가 복잡해짐.
  
  모델 : 애플리케이션의 데이터인 DB, 상수, 변수 등을 뜻함. 뷰에서 데이터를 생성하거나 수정하면 컨트롤러를 통해 모델을 생성하거나 갱신함.
  뷰 : inputbox, checkbox, textarea 등 사용자 인터페이스 요소를 나타낸다. 모델을 기반으로 사용자가 볼 수 있는 화면을 뜻하며 모델이 가지고 있는 정보를 따로 저장하지 않아야 하며 단순히 
       사각형 모양 등 화면에 표시되는 정보만 가지고 있어야함. 변경이 일어나면 컨트롤러에 이를 전달해야 함.
  컨트롤러 : 하나 이상의 모델과 하나 이상의 뷰를 이어주는 다리 역할을 하며 이벤트 등 메인 로직을 담당한다. 또, 모델과 뷰의 생명주기도 관리하며 모델이나 뷰의 변경 통지를 받으면 이를 해석해
           각각의 구성 요소에 해당 내용에 대해 알려준다.
           
  ## 1.1.9 MVP 패턴
  MVC패턴에서의 컨트롤러가 프레젠터로 교체된 패턴임.
  뷰와 프레젠터는 일대일 관계이므로 MVC패턴보다 더 강한 결합을 지닌 디자인 패턴임.
  
  ## 1.1.10 MVVM 패턴
  MVC의 컨트롤러가 뷰 모델로 바뀐 패턴임
  뷰모델 : 뷰를 추상화한 계층
  
  MVC패턴과는 다르게 커맨드와 데이터 바인딩을 가진다. 뷰와 뷰 모델 사이에 양방향 데이터 바인딩을 지원하여 UI를 별도의 코드 수정 없이 재사용할 수 있다. 또한 단위 테스팅하기 용이하다는 장점이 있다.
  EX) vue.js가 MVVM패턴의 대표적인 프레임워크이다.
 
# 1.2 프로그래밍 패러다임

  프로그래밍 패러다임은 개발자에게 프로그래밍 관저믈 갖게 해주는 역할을 하는 개발 방법론임.
  패러다임은 크게 선언형과 명령형으로 나누며 선언형은 함수형 명령형은 객체지향형과 절차지향형으로 나뉘게 된다.
  
  ## 1.2.1 선언형과 함수형 프로그래밍
    선언형 프로그래밍이란 '무엇을' 풀어내는가에 집중하는 패러다임. '프로그램은 함수로 이루어진 것이다.' 라는 명제가 담겨 있는 패러다임이며 함수형 프로그래밍은 선언형 패러다임의 일종임.
    
    함수형 프로그래밍은 '순수함수'들을 블록처럼 쌓아 로직을 구현하고 '고차함수'를 통해 재사용성을 높인 프로그래밍 패러다임이다.
    순수함수 : 출력이 입력에만 의존하는 것
    고차함수 : 함수가 함수를 값처럼 매개변수로 받아 로직을 생성할 수 있는 것을 말함.
    
    고차함수를 쓰기 위해선 해당 언어가 일급 객체라는 특징을 가져야 한다.
    일급객체의 특징 
    1) 변수나 메서드에 함수를 할당할 수 있다.
    2) 함수안에 함수를 매개변수라 담을 수 있다.
    3) 함수가 함수를 반환할 수 있다.
    
    함수형 프로그래밍은 이외에도 커링, 불변성 등 많은 특징이 있다.

  ## 1.2.2 객체지향 프로그래밍
    
    
   
    
    
    
    
    
